# 러스트 게임서버 엔진

### 1. 액터 모델
일반적인 서버는 요청-응답 모델이지만,
게임 서버는 빠른 응답을 위해 상태를 유지해야 합니다.

여러 사용자의 연결 상태를 유지하다 보면,
한 사용자의 네트워크 I/O를 기다리는 동안 데이터에 '락'을 걸어
CPU가 놀게 되는 비효율이 발생합니다.

액터 모델은 '락' 이나 '뮤텍스' 등을 사용하지 않아 CPU를 효율적으로 사용하고,
높은 확장성을 가진 모델입니다.


액터 모델은 모든 작업을 '액터' 라는 독립적인 단위로 추상화합니다.
각 액터는 다른 액터 메모리를 공유하지 않으며, 변경할 수 없습니다.
액터들은 '메시지' 를 주고받으며, 각 액터는 메시지를 비동기적으로 처리합니다.
액터는 메시지를 받아 자신의 상태를 변경하거나, 다른 액터를 생성하는 등의 작업을 합니다.


### 2. 서버 아키텍쳐

main 함수는 127.0.0.1:8080 주소에서 웹소켓을 열고 기다립니다.
만약 클라이언트가 서버 웹소켓에 연결하면, 클라이언트 액터를 생성합니다.

1. 클라이언트 액터

클라이언트 액터는 클라이언트 (사용자) 가 접속하면 대응하여 생기는 액터입니다.
클라이언트로부터 패킷을 받아 적절한 액터로 전달하고,
서버로부터 받은 데이터를 클라이언트 (사용자) 에게 전하는 역할을 합니다.


2. 세션 매니저

전체 사용자들을 관리하는 액터입니다.
연결된 사용자들 (클라이언트 액터) 의 목록을 가지고 있으며,
처음에 클라이언트 액터가 연결할 때 인증 프로토콜을 가지고 있습니다.
1) 클라이언트는 next.js 웹서버에 로그인 되어있는지 확인하고, 로그인 되어있다면 ticket (one-time-password) 을 요청합니다.
2) next.js 웹서버는 ticket을 발급하고, 클라이언트에 전송 및 redis 서버에 임시로 저장합니다.
3) 클라이언트는 발급받은 ticket을 게임서버에 전송합니다.
4) 세션매니저는 redis에 저장된 ticket과 대조해 next.js의 로그인 정보를 받아옵니다.
5) ticket이 없거나 로그인에 실패했다면, 게스트 사용자로 로그인합니다.
   
3. 룸 매니저

'룸'은 실제 게임 로직이 돌아가는 곳입니다.
룸 매니저는 전체 룸 들을 관리하는 액터입니다.
서버에 있는 전체 룸의 목록을 가지고 있으며,
룸을 생성하거나 닫을 수 있고
클라이언트 액터가 특정 룸에 join 하도록 RoomId를 알려줍니다.


   
4. 룸 액터

각 룸은 각자의 상태 (메모리) 를 가지고 있으며
룸에 join 한 클라이언트 액터들의 메시지를 받아 게임을 진행합니다.
모든 클라이언트 액터는 "Global" 룸에 로그인 시 join 하게 됩니다.





### 3. 프로토콜
1. 클라이언트 -> 서버

패킷의 첫 비트는 패킷의 유형을 나타냅니다.
예를 들어 0은 heartbeat (pingpong) 패킷,
1은 로그인과 관련된 패킷,
2는 텍스트 패킷,
3은 에러메시지 전송 패킷,
4는 바이너리 전송 패킷,
10은 게임과 관련된 패킷입니다.

게임과 관련된 패킷은 [10,OpCode,Payload] 형태로 구성되어 게임에서 서버로 전송합니다.
패킷을 받은 서버는 OpCode에 따라 패킷을 적절한 룸으로 전달하고
각 룸에서 Payload에 따라 적절하게 처리됩니다.

2. 서버 -> 클라이언트
마찬가지로 패킷의 첫 비트가 패킷의 유형을 나타냅니다.
현재 엔진에서는 게임 데이터를 바이너리 형태로 전송하기 때문에 4번을 이용하게 됩니다. (추후 10번으로 변경할 수도 있습니다)

